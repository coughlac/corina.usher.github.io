<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset="UTF-8">
    <title>Software Teaming</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>

<h1>Is Software Teaming Better Than Pairing?</h1>
<p>
    Software Teaming (formerly called Mob Programming) can be viewed as an extension of Pair Programming, sharing several key
    characteristics:
</p>
<ul>
    <li>A Driver controls the mouse and keyboard, thinking about the syntax and writing the actual code</li>
    <li>A Navigator provides instructions while a driver executes them</li>
    <li>Frequent rotation of roles among participants</li>
</ul>
<p>
    So, it should come as no surprise that it also shares certain challenges with Pair Programming.
    In particular, around the key areas of discipline and empathy.
</p>
<h2>Challenges with Pair Programming</h2>
<h3>The Discipline Factor</h3>
<p>
    <em>Maintaining frequent role rotations and adhering to defined roles is hard</em>
</p>
<p>
    It requires significant discipline. Without it, issues can arise such as:
</p>
<ul>
    <li><b> Domination:</b> One person might inadvertently take over the session, reducing the other's active
        participation
    </li>

    <li><b> Neglected Navigator Duties:</b> Both participants may focus too much on the driver's role, concentrating on
        code syntax and semantics. Important elements of the Navigator role, such as tracking potential issues,
        identifying refactoring opportunities, and maintaining a big-picture perspective may be overlooked
    </li>
</ul>
<br/>
<p>
    <em>The Blurring of Roles in Modern Pair Programming</em>
</p>
<p>
    In today's development environments, with collaborative tools such as Tuple, Pop or JetBrains Code With Me, the
    boundaries between roles have become even less distinct.
</p>
<p>
    It is an almost seamless transition for the Navigator to seize control and start typing â€” a simple "pointer tussle".
    This is a significant change from the traditional method of physically handing someone control of the
    keyboard. The increased flexibility allows participants to both easily contribute in both roles.
<p>
<p>
    Modern tooling, whilst making the rotation of roles easier, makes the adherence to roles harder.
</p>
<h3>The Empathy Factor</h3>
<p>
    Pairing demands empathy. Participants must feel comfortable with their partners, considering factors like:
</p>
<ul>
    <li><b>Skill Level:</b> Identifying learning/coaching opportunities, complementary skill-sets or fresh perspectives
    </li>
    <li><b>Personality and mannerism:</b> Openness, body language, verbal habits, patience levels
    </li>
    <li><b>Professionalism:</b> Communication styles, feedback, accountability, time management</li>
</ul>
<p>
    These elements impact the free expression of opinions, session flow, and overall output. Building effective Pairing
    relationships often requires time, team-building techniques, and regular, short sessions.
</p>
<h2>Software Teaming Challenges</h2>
<h3>Pairing Challenges, but at scale?</h3>
<p>
    Empathy and discipline are key factors to successful Pairing sessions. In Software Teaming, these factors become
    even more important as they need to be practiced by the entire team, essentially "scaling up" the challenge.
</p>
<p>
    This can be particularly difficult when:
</p>
<ul>
    <li>The practice is new to the team, and ground rules are still being established</li>
    <li>The team is newly formed, and empathy between members is still developing</li>
</ul>
<h2>Not Better, or Worse, Just Different</h2>
<p>
    Rather than viewing Software Teaming as preferable to Pairing, perhaps it's more accurate to see it as a different
    tool, with its own advantages and challenges. While it offers the benefits of whole-team collaboration, it also
    requires a higher level of collective discipline and empathy.

    When deciding between Pairing and Software Teaming, consider these key factors:
</p>
<ul>
    <li>The team's size and dynamics</li>
    <li>The complexity of the task at hand</li>
    <li>The team's experience with collaborative programming practices</li>
    <li>The desired level of knowledge sharing and collective problem-solving</li>
</ul>
<p>
    Ultimately, both practices can be highly effective when implemented with care, discipline, and a focus on continuous
    improvement. Teams may find that a mix of both approaches, applied to appropriate scenarios, yields the best
    results.
</p>
<p>
    The Agile principle to keep in mind is <i>people over process</i> and to adapt the processes to meet the team's
    needs.
</p>
<h2> Leveraging Software Teaming</h2>
<h3> Collaborative Exploration</h3>
<p>
    Software Teaming is a great choice when tackling tasks with potentially, multiple solutions, such as 'spiking'. In
    these scenarios, the team collectively explores various approaches to determine the optimal path forward. This
    collaborative process offers several unique advantages:
</p>
<ul>
    <li><b>Interactive Learning:</b> The process resembles an interactive lecture, where knowledge is shared and
        absorbed collectively. This approach helps everyone contribute meaningfully to the task at hand
    </li>
    <li><b>Shared Discovery:</b> Everyone on the team embarks on the journey of exploration together, fostering a sense
        of unity and shared purpose
    </li>
    <li><b>Inclusive Decision-Making:</b> From product owners to developers, everyone has an opportunity to provide
        valuable input and gain insights from the experience.
    </li>
    <li><b>Diverse Perspectives:</b> By involving the entire team, you benefit from a wide range of perspectives,
        leading to more comprehensive and well-rounded solutions
    </li>
    <li><b>Immediate Feedback:</b> Ideas can be tested and refined on the spot, with instant feedback from the entire
        team
    </li>
</ul>
<p>
    In my experience, these spiking sessions tend to have higher engagement levels. The interactive nature of Software
    Teaming in this context naturally encourages participation from all team members.
    This approach, not only leads to better technical outcomes but also strengthens team cohesion and shared
    understanding of the project's direction.
</p>

<h3>The Power of Unanimous Agreement - Creating a 'Snapshot of Truth'</h3>
<p>
    One of the most powerful aspects of using Software Teaming for these sessions is its ability to help the team reach
    a consensus on what we might call a <i>snapshot of truth</i> about the application. This approach is particularly
    valuable when:
</p>
<ul>
    <li>Defining the ubiquitous language of the domain model</li>
    <li>Discussing and documenting architectural designs</li>
</ul>
<p>
    By leveraging Software Teaming for these traditionally whiteboard-centric tasks, teams can create a more dynamic,
    inclusive, and productive environment for crucial discussions and decision-making processes.
</p>

<h2>Conclusion</h2>
<p>The benefits of Software Teaming are evident, particularly when exploring new ideas or striving for a
    shared understanding. However, the successful adoption of Software Teaming may be influenced by the team's size,
    composition, and their familiarity with other collaborative methods like Pair Programming. These factors should be
    considered when setting expectations regarding the rate of adoption.
</p>

<h1>References</h1>
<ol>
    <li>
        <a href="https://woodyzuill.com/2024/02/software-teaming-mob-programming/"
           alt="Zuill, W. (2024, Feb). Software Teaming/Mob Programming.">Zuill, W. (2024, Feb). Software
            Teaming/Mob Programming</a>
    </li>
    <li>
        <a href="https://www.researchgate.net/publication/2522276_Mob_Programming_and_the_Transition_to_XP"
           alt="Hohman M, Andrew D PhD, Slocum C. (2002, Aug). Mob Programming and the Transition to XP">Hohman M,
            Andrew D PhD, Slocum C. (2002, Aug). Mob Programming and the Transition to XP</a>
    </li>
</ol>
</body>
</html>